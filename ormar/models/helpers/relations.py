from typing import TYPE_CHECKING, Type

from ormar import ForeignKey, ManyToMany
from ormar.fields import ManyToManyField
from ormar.fields.foreign_key import ForeignKeyField
from ormar.models.helpers.pydantic import reverse_field_not_already_registered
from ormar.models.helpers.sqlalchemy import adjust_through_many_to_many_model
from ormar.relations import AliasManager

if TYPE_CHECKING:  # pragma no cover
    from ormar import Model

alias_manager = AliasManager()


def register_relation_on_build(new_model: Type["Model"], field_name: str) -> None:
    """
    Registers ForeignKey relation in alias_manager to set a table_prefix.
    Registration include also reverse relation side to be able to join both sides.

    Relation is registered by model name and relation field name to allow for multiple
    relations between two Models that needs to have different
    aliases for proper sql joins.

    :param new_model: constructed model
    :type new_model: Model class
    :param field_name: name of the related field
    :type field_name: str
    """
    alias_manager.add_relation_type(new_model, field_name)


def register_many_to_many_relation_on_build(
    new_model: Type["Model"], field: Type[ManyToManyField]
) -> None:
    """
    Registers connection between through model and both sides of the m2m relation.
    Registration include also reverse relation side to be able to join both sides.

    Relation is registered by model name and relation field name to allow for multiple
    relations between two Models that needs to have different
    aliases for proper sql joins.

    By default relation name is a model.name.lower().

    :param new_model: model on which m2m field is declared
    :type new_model: Model class
    :param field: relation field
    :type field: ManyToManyField class
    """
    alias_manager.add_relation_type(field.through, new_model.get_name(), is_multi=True)
    alias_manager.add_relation_type(field.through, field.to.get_name(), is_multi=True)


def expand_reverse_relationships(model: Type["Model"]) -> None:
    """
    Iterates through model_fields of given model and verifies if all reverse
    relation have been populated on related models.

    If the reverse relation has not been set before it's set here.

    :param model: model on which relation should be checked and registered
    :type model: Model class
    """
    for model_field in model.Meta.model_fields.values():
        if issubclass(model_field, ForeignKeyField):
            child_model_name = model_field.related_name or model.get_name() + "s"
            parent_model = model_field.to
            child = model
            if reverse_field_not_already_registered(
                child, child_model_name, parent_model
            ):
                register_reverse_model_fields(
                    parent_model, child, child_model_name, model_field
                )


def register_reverse_model_fields(
    model: Type["Model"],
    child: Type["Model"],
    related_name: str,
    model_field: Type["ForeignKeyField"],
) -> None:
    """
    Registers reverse ForeignKey field on related model.
    By default it's name.lower()+'s' of the model on which relation is defined.

    But if the related_model name is provided it's registered with that name.
    Autogenerated reverse fields also set related_name to the original field name.

    :param model: related model on which reverse field should be defined
    :type model: Model class
    :param child: parent model with relation definition
    :type child: Model class
    :param related_name: name by which reverse key should be registered
    :type related_name: str
    :param model_field: original relation ForeignKey field
    :type model_field: relation Field
    """
    if issubclass(model_field, ManyToManyField):
        model.Meta.model_fields[related_name] = ManyToMany(
            child,
            through=model_field.through,
            name=related_name,
            virtual=True,
            related_name=model_field.name,
        )
        # register foreign keys on through model
        adjust_through_many_to_many_model(model, child, model_field)
    else:
        model.Meta.model_fields[related_name] = ForeignKey(
            child, real_name=related_name, virtual=True, related_name=model_field.name,
        )


def register_relation_in_alias_manager(
    new_model: Type["Model"], field: Type[ForeignKeyField], field_name: str
) -> None:
    """
    Registers the relation (and reverse relation) in alias manager.
    The m2m relations require registration of through model between
    actual end models of the relation.

    Delegates the actual registration to:
    m2m - register_many_to_many_relation_on_build
    fk - register_relation_on_build

    :param new_model: model on which relation field is declared
    :type new_model: Model class
    :param field: relation field
    :type field: ForeignKey or ManyToManyField class
    :param field_name: name of the relation key
    :type field_name: str
    """
    if issubclass(field, ManyToManyField):
        register_many_to_many_relation_on_build(new_model=new_model, field=field)
    elif issubclass(field, ForeignKeyField):
        register_relation_on_build(new_model=new_model, field_name=field_name)
